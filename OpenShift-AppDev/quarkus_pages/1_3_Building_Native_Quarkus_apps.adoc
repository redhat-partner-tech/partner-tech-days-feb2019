*Building Native Quarkus Apps*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Let's now produce a native executable for our application. It improves the startup time of the application, and produces a minimal disk and memory footprint. The executable would have everything to run the application including the "JVM" (shrunk to be just enough to run the application), and the application. This is accomplished using *GraalVM*.

GraalVM is a universal virtual machine for compiling and running applications written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Groovy, Kotlin, Clojure, and LLVM-based languages such as C and C++. It includes ahead-of-time compilation, aggressive dead code elimination, and optimal packaging as native binaries that moves a lot of startup logic to build-time, thereby reducing startup time and memory resource requirements significantly.

image:images/native-image-process.png[native-image-process.png]

GraalVM is already installed for you. Inspect the value of the *GRAALVM_HOME* variable in the Terminal with:

....
echo $GRAALVM_HOME
....

*Build the image*
~~~~~~~~~~~~~~~~~

Within the *pom.xml* is the declaration for the Quarkus Maven plugin which contains a profile for *native-image*:

....
  <profile>
    <id>native</id>
    <build>
      <plugins>
        <plugin>
          <groupId>io.quarkus</groupId>
          <artifactId>quarkus-maven-plugin</artifactId>
          <version>${quarkus.version}</version>
          <executions>
            <execution>
              <goals>
                <goal>native-image</goal>
              </goals>
              <configuration>
                <enableHttpUrlHandler>true</enableHttpUrlHandler>
              </configuration>
            </execution>
          </executions>
        </plugin>
      </plugins>
    </build>
  </profile>
....

We use a profile because, you will see very soon, packaging the native image takes a few seconds. However, this compilation time is only incurred once, as opposed to every time the application starts, which is the case with other approaches for building and executing JARs.

Create a native executable by once again opening the command palette and choose *Build Native Quarkus App*. This will execute *mvn package -Pnative behind* the scenes. The *-Pnative* argument selects the *native* maven profile which invokes the Graal compiler.

*This will take about 2-3 minutes to finish. Wait for it!*

[NOTE]
====
Since we are on Linux in this environment, and the OS that will eventually run our application is also Linux, we can use our local OS to build the native Quarkus app. If you need to build native Linux binaries when on other OS's like Windows or Mac OS X, you can use -Dquarkus.native.container-runtime=[podman | docker]. You'll need either Docker or Podman installed depending on which runtime you want to use!
====

In addition to the regular files, the build will produce target/people-1.0-SNAPSHOT-runner. This is a native Linux binary. Not a shell script, or a JAR file, but a native binary.

*Run native image*
~~~~~~~~~~~~~~~~~~

Since our environment here is Linux, you can just run it. In the terminal, run:
....
target/people-1.0-SNAPSHOT-runner -Dquarkus.http.port=8081
....

Notice the amazingly fast startup time:
....
2019-07-10 04:04:11,817 INFO  [io.quarkus] (main) Quarkus 0.18.0 started in 0.015s. Listening on: http://[::]:8081
2019-07-10 04:04:11,818 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, jdbc-h2, narayana-jta, resteasy]
....
That's 15 milliseconds to start up.

And extremely low memory usage as reported by the Linux ps utility. While the app is running, open another Terminal (click the + button on the terminal tabs line) and run:

....
ps -o pid,rss,command -p $(pgrep -f runner)
....
You should see something like:

....
   PID   RSS COMMAND
 16017 53816 target/people-1.0-SNAPSHOT-runner
....
This shows that our process is taking around 50 MB of memory (Resident Set Size, or RSS). Pretty compact!

[NOTE]
====
The RSS and memory usage of any app, including Quarkus, will vary depending your specific environment, and will rise as the application experiences load.
====

Make sure the app is still working as expected (we'll use curl this time to access it directly). In a new Terminal run:

....
curl http://localhost:8081/hello/greeting/quarkus
....

You should see:

....
hello quarkus from <your-hostname>
....

Nice!

*Cleanup*
~~~~~~~~~

Go to the Terminal in which you ran the native app and press *CTRL+C* to stop our native app (or close the Terminal window with the X button next to its title). *Be sure to leave your Live Coding Terminal open!*

*Congratulations!*
~~~~~~~~~~~~~~~~~~

You've now built a Java application as an executable JAR and a Linux native binary. We'll explore the benefits of native binaries later in when we start deploying to Kubernetes.


link:1_4_Deploying_to_the_cloud.adoc[*NEXT LAB -> Deploying to the cloud*]